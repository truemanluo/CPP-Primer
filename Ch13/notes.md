#### 关于默认构造函数：
- 当不存在默认构造函数时，编译器会生成一个默认构造函数。但一旦显式声明构造函数后，编译器不再生成默认构造函数，**除非自己再定义一个默认构造函数**


#### 关于拷贝构造函数：
> 用来初始化非引用类类型参数

- 编译器总是会生成一个默认的拷贝构造函数，**即使自己已经定义其他的拷贝构造函数**
- 拷贝构造函数的参数必须是引用类型
  > 这与拷贝构造函数的调用时机有关，**拷贝构造函数用来初始化非引用类类型参数**，如果其传入的参数不是引用类型，则需要拷贝实参，而拷贝实参需要调用拷贝构造函数（陷入一个死锁状态）

#### 关于拷贝赋值运算符（用于规定对象赋值时的行为）
> 其实就是一个名为`operator=`的函数，赋值时会被调用。如题13.4中，`*heap = local`时不是调用拷贝构造函数，而是拷贝赋值运算符。
> 
> 注意两者拷贝赋值运算符和拷贝构造函数的区别很重要：
> - 拷贝**构造**是新建一个对象
> - 赋值是对象已经存在，只是修改原来对象的成员值


#### 关于析构函数：

- 析构函数**本身并不直接销毁成员**，成员是在析构函数体之后隐含的析构阶段被销毁的。在整个对象销毁过程中，**析构函数是作为成员销毁步骤之外的另一部分进行的。**
- 普通指针（内置类型）没有析构函数，智能指针有
- 当指向一个对象的引用或指针离开作用域时，析构函数不会执行

#### 右值引用

> 左值和右值是表达式的属性，一般而言，左值表达式关心对象的身份，右值表达式关心对象的值

C++ 11中引入了移动的概念，主要有两点考虑：
- 在某些情况下，对象拷贝后就立即被销毁了。在这种情况下移动比拷贝更高效（比如，拷贝一个vector需要拷贝其中的所有元素，移动只需要修改指针）
- 移动某些不能拷贝的对象（`unique_ptr`和I/O缓冲）


右值引用是为了支持**移动**的操作，通过`&&`获得。
> 一个重要性质：右值引用只能绑定到一个即将销毁的对象

```
int i = 42;
int &r = i; // 正确
int &&rr = i; // 错误，不能将右值引用绑定到一个左值上
int &r2 = i * 42; // 错误，i*42是临时对象（右值）
int &&r2 = i * 42; // 正确
const int &r2 = i * 42; // 正确，常量引用
```

右值的两个特点：
- 所引用的对象将要被销毁
- 该对象没有其他用户

因此可以自由接管所引用的对象资源

`move`函数可以显示将左值转化为对应的右值引用：

`int &&r3 = std::move(rr1)`

