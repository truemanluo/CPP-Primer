**12.3**

不需要，常量对象本来就不应该被修改。但是这样做是合法的，因为不是修改data本身，而是修改data指向的对象。

**12.4**

因为`size_t`的类型是`unsigned`

> Q1: 为什么不能定义一个`static`的`vector`进行共享？
> 
> A: 也不是不行，但是`static`成员的生命周期与程序一致，程序执行结束才会销毁，而通过 `shared_ptr`定义的成员变量会在引用计数为0时销毁。`shared_ptr`存在于栈上，`static`成员存在与静态存储区。
> 
> Q2: new的StrBlob对象为什么必须是一个指针？
>
> A: 因为自由分配的内存是无名的，因此`new`无法为其分配的对象命名，只能返回指向该对象的指针

**12.10**

对。

**12.11**

`shared_ptr<int>(p.get())`是一个匿名智能指针，离开作用域（调用process）后其被销毁，
导致其指向的对象被释放（匿名对象的引用计数变为0），因此访问`*p`是一个非法行为。**再者，当离开`main`函数后`p`会被再次释放，发生未定义行为。**

**12.12**

1. 合法，
2. 不合法，`shared_ptr`的构造函数是`explicit`的，不存在从普通动态指针到它的转化
3. 不合法，同上
4. 合法，但是会导致`p`指向的对象被释放，可能潜在的导致`p`被`delete`多次或者被非法引用

**12.13**

导致智能指针所指对象被删除（double free problem）

**12.17**

(a) 不合法，用`int`类型初始化`unique_ptr` 

(b) 合法，但没有提供删除器

(c) 合法，但是很危险，`*pi2`可能会被`unique_ptr`释放，导致其失效

(d) 不合法，离开作用域后会使用`delete`删除一个不是用`new`分配的指针

(e) 合法

(f) 合法，但是很危险

**12.22** 

重载const对象可能使用的成员函数为`const`（`const`对象只能访问`const`成员函数）

**Best practice**

- 不使用相同的内置指针值初始化（或reset）多个智能指针
- 不delete get()返回的指针
- 不使用get初始化或者reset另一个智能指针（相当于不同的两组shared_ptr）
- 如果使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器