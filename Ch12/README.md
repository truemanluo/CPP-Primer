### FAQ

1. 1、2、3中初始化的方式有何不同

```
int *p1 = new int; // 1，默认初始化，内置类型初始化为**未定义**，对象用默认构造函数初始化
int *p2 = new int(); // 2，值初始化为0
int *p3 = new int(19); // 3，直接初始化
```

2. new禁止抛出`bad_alloc`异常：
   
   使用placement new: `new (nothrow) int // 分配失败返回空指针` 

3. `get`会返回一个普通指针，只有在确定代码不会delete指针的情况下才能使用`get`。永远不要用`get`初始化另一个智能指针或者赋值

4. 智能指针和异常

    > - 无论是否发生异常，智能指针都将会被释放，而普通指针在delete之前发生异常会导致内存泄漏
    > - **如果使用智能指针管理的资源不是new分配的内存，记住传递给他一个删除器**

5. 管理哑类（没有析构函数）
    > 和管理动态内存相似，初始化一个`shared_ptr`，并传递一个自己的`deleter`，保证发生异常时资源也能正确释放

6. `unique_ptr`：拥有它所指的对象
   - 不支持拷贝赋值，但可以使用`release`和`reset`来转移控制权
    ```
    unique_ptr<string> p2(p1.release());
    ```

   - 将销毁时支持拷贝（比如是一个函数的局部变量时）


7. `weak_ptr`：不控制所指对象，指向一个由`shared_ptr`管理的对象（伴随指针）
   > 主要目的是防止通过`shared_ptr`访问已经不存在的对象

8. 函数指针
   > 存储函数地址的变量

   ```
   auto f1(int) -> int (*)(int*, int); // 尾置类型
   ```